{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":1,"trackMouse":0.32,"mouseMomentum":1,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime; uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.20392156862745098, 0.7215686274509804, 0.2901960784313726); case 1: return vec3(0.25882352941176473, 0.9215686274509803, 0.5215686274509804); case 2: return vec3(0.023529411764705882, 0.2784313725490196, 0.12549019607843137); case 3: return vec3(0.5215686274509804, 1, 0.7137254901960784); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0 + 0.025 * a * (1.0-a); return kLMStoCONE * (lms * lms * lms); }vec3 getGradientColor(float position) { position = clamp(position, 0.0, 1.0); for (int i = 0; i < 4 - 1; i++) { float colorPosition = float(i) / float(4 - 1); float nextColorPosition = float(i + 1) / float(4 - 1); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(getColor(i)); vec3 linEnd = linear_from_srgb(getColor(i + 1)); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return getColor(4 - 1); }out vec4 fragColor;vec3 applyColorToPosition(float position) { vec3 color = vec3(0); position -= (uTime * 0.01 + 0.2000); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color += dither; return color; }vec3 linearGrad(vec2 uv) { float position = (uv.x+0.5); return applyColorToPosition(position); }vec3 getGradient(vec2 uv) { return linearGrad(uv); }vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0.20392156862745098, 0.7215686274509804, 0.2901960784313726); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.56, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.3200); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":true}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"noise","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 hash3(vec2 p) { vec3 q = vec3(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9))); return fract(sin(q)*43758.5453); }float voronoise(vec2 uv, vec2 textureCoord) { float u = 1.; float v = 1.; uv *= vec2(1.0000, 1.0 - 1.0000); uv *= 2.91;vec2 x = uv; vec2 p = floor(x); vec2 f = fract(x); float k = 1.0 + 63.0 * pow(1.0-v,4.0); float va = 0.0; float wt = 0.0; for( int j=-2; j<=2; j++ ) for( int i=-2; i<=2; i++ ) { vec2 g = vec2( float(i),float(j) ); vec3 o = hash3( p + g ) * vec3(u,u,1.0); o.xy += 0.5 * vec2( sin(uTime * 0.1 + 0.0000 + o.x * 6.28), cos(uTime * 0.1 + 0.0000 + o.y * 6.28) ); vec2 r = g - f + o.xy; float d = dot(r,r); float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k ); va += o.z*ww; wt += ww; } return va/wt; } vec2 getVoronoiNoise(vec2 uv, vec2 textureCoord) { vec2 offset = vec2(voronoise(uv, textureCoord), voronoise(uv + vec2(9.2, 1.2), textureCoord));return mix(textureCoord, offset, 0.4600); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return getVoronoiNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.14126330350187166, 0.03247482677236535) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.14126330350187166, 0.03247482677236535), mPos, floor(1.0000)); vec2 drift = vec2(0, 0.0000 * uTime * 0.0125); pos += drift * rot(0.1556 * -2. * PI); vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * 1.0000; st = rot(0.1556 * -2. * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"polar","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float PI = 3.1415926;vec2 polar(vec2 uv, vec2 pos) { uv -= pos; float angle = atan(uv.y, uv.x); float radius = length(uv);float xCoord = mod((angle + 0.1566 * 2.0 * PI) + (uTime * 0.05) + PI, 2.0 * PI) / (2.0 * PI); float yCoord = radius * 1.0000;return fract(vec2(yCoord, xCoord)); }void main() { vec2 uv = vTextureCoord; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec2 pos = vec2(0.22036903075909017, 0.11598901350477364) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 polarCoord = polar(uv * aspectRatio, pos * aspectRatio); vec4 color1 = texture(uTexture, polarCoord); vec2 oppositePolar = vec2(polarCoord.x, polarCoord.y > 0.5 ? polarCoord.y - 0.5 : polarCoord.y + 0.5); vec4 color2 = texture(uTexture, oppositePolar); float seamBlend = 0.0; float blendWidth = 0.5000 * 0.1; if (polarCoord.y < blendWidth || polarCoord.y > 1.0 - blendWidth) { if (polarCoord.y < blendWidth) { seamBlend = 1.0 - (polarCoord.y / blendWidth); } else { seamBlend = (polarCoord.y - (1.0 - blendWidth)) / blendWidth; } seamBlend = smoothstep(0.0, 1.0, seamBlend); } fragColor = mix(color1, color2, seamBlend); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.6400 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.6400, 1.0 - 0.6400); float halfRadius = 0.2400 * 0.5; float innerEdge = halfRadius - 0.7200 * halfRadius * 0.5; float outerEdge = halfRadius + 0.7200 * halfRadius * 0.5; vec2 pos = vec2(0.5266299223286706, 0.4536871172066058); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.1782 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.1782 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0.043137254901960784, 0.0392156862745098, 0.0392156862745098), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0.08,"mouseMomentum":1,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.0000 - 0.1, 0.0000, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.4800)) * stepFactor; vec2 pos = vec2(0.52946238401823, 0.38614749646623947) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0800); float weight = 1.0; float bnoz = randFibo(st) * 0.4800; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.4800; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.5600 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.4800 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(0.5215686274509804, 1, 0.7137254901960784); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.4800 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"zoomBlur","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor; float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 RadialBlur(sampler2D tex, vec2 uv) { if (1.0000 == 0.0) { return texture(tex, uv); } vec2 pos = vec2(0.7091660177738478, 0.00213650997101289) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x/uResolution.y; vec2 dir = uv - pos; dir.x *= aspectRatio; float dist = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)); dist = ease(0, max(0.,1.-dist * 4. * (1. - 1.0000))); if (0 == 1) { dist = max(0., (0.5 - dist)); }float amount = (1.0000 + 0.2) * dist * 0.01; if(0 == 1) amount *= 0.5; if(0 == 2) amount *= 0.25; if (amount < 0.0001) { return texture(tex, uv); } vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight; vec2 normalizedDir = normalize(dir); normalizedDir.x /= aspectRatio; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = float(i) * amount; vec2 sampleDir = normalizedDir * offset; vec4 sample1 = texture(tex, uv + sampleDir); vec4 sample2 = texture(tex, uv - sampleDir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }color = color / total_weight; if(0 == 3) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; } return color; }vec4 radialBlurPass(vec2 uv) {return RadialBlur(uTexture, uv); }vec4 getPassColor(vec2 uv) { return radialBlurPass(uv); } void main() { vec2 uv = vTextureCoord; vec4 color = getPassColor(uv); fragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor; float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 RadialBlur(sampler2D tex, vec2 uv) { if (1.0000 == 0.0) { return texture(tex, uv); } vec2 pos = vec2(0.7091660177738478, 0.00213650997101289) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x/uResolution.y; vec2 dir = uv - pos; dir.x *= aspectRatio; float dist = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)); dist = ease(0, max(0.,1.-dist * 4. * (1. - 1.0000))); if (0 == 1) { dist = max(0., (0.5 - dist)); }float amount = (1.0000 + 0.2) * dist * 0.01; if(1 == 1) amount *= 0.5; if(1 == 2) amount *= 0.25; if (amount < 0.0001) { return texture(tex, uv); } vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight; vec2 normalizedDir = normalize(dir); normalizedDir.x /= aspectRatio; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = float(i) * amount; vec2 sampleDir = normalizedDir * offset; vec4 sample1 = texture(tex, uv + sampleDir); vec4 sample2 = texture(tex, uv - sampleDir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }color = color / total_weight; if(1 == 3) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; } return color; }vec4 radialBlurPass(vec2 uv) {return RadialBlur(uTexture, uv); }vec4 getPassColor(vec2 uv) { return radialBlurPass(uv); } void main() { vec2 uv = vTextureCoord; vec4 color = getPassColor(uv); fragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor; float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 RadialBlur(sampler2D tex, vec2 uv) { if (1.0000 == 0.0) { return texture(tex, uv); } vec2 pos = vec2(0.7091660177738478, 0.00213650997101289) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x/uResolution.y; vec2 dir = uv - pos; dir.x *= aspectRatio; float dist = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)); dist = ease(0, max(0.,1.-dist * 4. * (1. - 1.0000))); if (0 == 1) { dist = max(0., (0.5 - dist)); }float amount = (1.0000 + 0.2) * dist * 0.01; if(2 == 1) amount *= 0.5; if(2 == 2) amount *= 0.25; if (amount < 0.0001) { return texture(tex, uv); } vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight; vec2 normalizedDir = normalize(dir); normalizedDir.x /= aspectRatio; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = float(i) * amount; vec2 sampleDir = normalizedDir * offset; vec4 sample1 = texture(tex, uv + sampleDir); vec4 sample2 = texture(tex, uv - sampleDir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }color = color / total_weight; if(2 == 3) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; } return color; }vec4 radialBlurPass(vec2 uv) {return RadialBlur(uTexture, uv); }vec4 getPassColor(vec2 uv) { return radialBlurPass(uv); } void main() { vec2 uv = vTextureCoord; vec4 color = getPassColor(uv); fragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;vec4 finalPass(vec2 uv) { if (1.0000 == 0.00) { return texture(uBgTexture, uv); } vec4 blurredColor = texture(uTexture, uv); vec4 originalColor = texture(uBgTexture, uv); vec2 pos = vec2(0.7091660177738478, 0.00213650997101289) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x/uResolution.y; float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000))); if (0 == 1) { dist = max(0., (0.5 - dist)); }return mix(originalColor, blurredColor, (1.0000 * dist > 0.001) ? 1.0 : 0.0); }vec4 getPassColor(vec2 uv) { return finalPass(uv); } void main() { vec2 uv = vTextureCoord; vec4 color = getPassColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"includeBg":true}]}}],"options":{"name":"Polaris (Remix)","fps":120,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.25","id":"0FGEQLKyOiRDsVetSUzq"}